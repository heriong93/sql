--정렬 시 기본default는 asc 오름차순
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date;

SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date DESC;

-- 칼럼의 이름 지정 후 이름으로 호출 
SELECT employee_id, last_name, salary*12 annsal 
FROM employees
ORDER BY annsal;

--칼럼의 순서번호로 호출
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY 3;

--부서는 오름차순으로 정렬 후, 그 안의 월급은 내림차순으로 정렬해줌
SELECT last_name, department_id, salary
FROM employees
ORDER BY department_id, salary DESC;

-- select에 hire_date가 없더라도 employee 테이블에 있기 때문에 정렬 가능
SELECT employee_id, salary 
FROM employees
ORDER BY hire_date;

-- &를 추가하면, employee_id 를 대체할 제목을 기재해 입력값을 받을 수 있다 //문자열은 ' '사이에 적어줘야함.
SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE employee_id = &employee_num;

--UNDEFINE 저장된 값을 지워줌
UNDEFINE &column_name;

-- 기재한 칼럼에 대한 값을 출력해줌 (employee_id, last_name, &column_name AKA입력값)
--WHERE 입력한 조건 입력
SELECT employee_id, last_name, job_id, &column_name
FROM employees
WHERE &condition
ORDER BY &order_column; 


--COLUMN_NAME 창이 뜨면 department_id 넣으면 SELECT에 포함됨. &&는 영구적인 값을 저장해줌 
SELECT employee_id, last_name, job_id, &&column_name
FROM employees
ORDER BY &column_name;


--영구 지정되어있어서 실행에러
SELECT employee_id, salary
FROM employees
ORDER BY &column_name;

--영구지정한 내용을 삭제하기 위해 UNDEFINE 사용
UNDEFINE &column_name;

SELECT *
FROM job_history;

--UNION은 중복된 값 제거해줌 employees 에 107개 job_history에 10개 . 중복값 2개 삭제된 값이 나옴 
SELECT employee_id
FROM employees
UNION
SELECT employee_id
FROM job_history;

--UNION ALL은 중복값이 제거안됨. 출력하면 총 107+10개 117개 다 나옴
SELECT employee_id
FROM employees
UNION ALL
SELECT employee_id
FROM job_history
ORDER BY employee_id;

--INTERSECT는 교차 된 값만 출력해줌. 즉 중복된 값만 나옴 
SELECT employee_id, job_id
FROM employees
INTERSECT
SELECT employee_id, job_id
FROM job_history;

--intersect의 순서가 바뀌어도 결과는 똑같이 나온다 
SELECT employee_id, job_id
FROM job_history
INTERSECT
SELECT employee_id, job_id
FROM employees;

--105개 출력 
SELECT employee_id, job_id
FROM employees
MINUS
SELECT employee_id, job_id
FROM job_history;

--8개 출력됨 . 
SELECT employee_id, job_id
FROM job_history
MINUS
SELECT employee_id, job_id
FROM employees;

DESC dual;

SELECT *
from dual;

SELECT sysdate
FROM dual;

--대소문자 구분 
SELECT 'The job id for ' || UPPER(last_name)|| ' is ' || LOWER(job_id) AS "EMPLOYEE DETAILS" 
FROM employees;

--이름을 찾을 때 칼럼의 모든 단어를 소문자로 묶어놓고 찾으면 실수없이 찾기 쉬워짐
SELECT employee_id, last_name, department_id
FROM employees
WHERE LOWER(last_name) = 'higgins';

-- substring 자리부터 잘라내겠다 
SELECT last_name, SUBSTR (last_name, 4)
FROM employees
WHERE department_id = 110;

--substring 2,2 두번째 자리에서 시작해서 두개만 잘라주기 
SELECT last_name, SUBSTR (last_name, 2,2)
FROM employees
WHERE department_id = 110;

--뒤에서부터 3번째 자리부터 2자리 
SELECT last_name, SUBSTR (last_name,-3,2)
FROM employees
WHERE department_id = 110;

SELECT employee_id, CONCAT(first_name, last_name) NAME,
job_id, LENGTH (last_name), INSTR (last_name, 'a') "Contains 'a'?"
FROM employees
WHERE SUBSTR (job_id, 4) = 'REP';

--LTRIM 왼쪽 문자 잘라내기 
SELECT LTRIM('yyedaymy', 'yea')
FROM dual;

--RTRIM 오른쪽 문자 잘라내기 
SELECT RTRIM('yyedaymy', 'yea')
FROM dual;
--ROUNDING반올림
SELECT 
        ROUND(345.678) AS round1,
        ROUND(345.678, 0) AS round2, 
        ROUND(345.678, 1) AS round3, 
        ROUND(345.678, -1)  AS round4
FROM dual;
--TRUNCATE 절삭 
SELECT 
        TRUNC(345.678) AS round1,
        TRUNC(345.678, 0) AS round2,
        TRUNC(345.678, 1) AS round3,
        TRUNC(345.678, -1)  AS round4
FROM dual;
--MOD: 월급을 5000으로 나눈 후 남은 값을 표출해줌 
SELECT last_name, salary, MOD(salary,5000)
FROM employees;

--1) 
SELECT sysdate AS "Date"
FROM dual;

--2) 
SELECT employee_id, last_name, salary, ROUND (salary *1.15) as "New Salary"
FROM employees;

--3) 
SELECT employee_id, last_name, salary, ROUND(salary*1.15) "New Salary", (salary*1.15) - salary "Increase"
FROM employees;

--4) 
SELECT UPPER(last_name) name, LENGTH(last_name) name_length 
FROM employees
WHERE UPPER (SUBSTR( last_name, 1,1)) IN ('J', 'A','M')
ORDER BY 1;

SELECT sysdate
FROM dual;

---------날짜함수-----
SELECT last_name, ROUND((SYSDATE- hire_date) /7) as weeks
FROM employees
WHERE department_id = 90;

SELECT employee_id, hire_date, MONTHS_BETWEEN (sysdate, hire_date) TENURE, 
ADD_MONTHS (hire_date, 6) REVIEW, 
NEXT_DAY (hire_date, '금'), LAST_DAY (hire_date)
FROM employees;

--오늘날짜 기준 year반올림(7월 기준 반올림) / month(15일 자정 중심으로 반올림)/ day (수요일 낮 12시 기준으로 반올림-그 다음주 혹은 전주로 반올림됨)/dd(하루의 가운데, 12시 기준)
SELECT 
    ROUND(SYSDATE, 'YEAR'), 
    ROUND(SYSDATE, 'MONTH'),
    ROUND(SYSDATE, 'DAY'),
    ROUND(SYSDATE, 'DD')
FROM dual;
--TRUNCATE YEAR(23년1월1일) MONTH(23년 12월 1일)
SELECT 
    TRUNC(SYSDATE, 'YEAR'), 
    TRUNC(SYSDATE, 'MONTH'),
    TRUNC(SYSDATE, 'DAY'),
    TRUNC(SYSDATE, 'DD')
FROM dual;

SELECT *
FROM employees
WHERE employee_id = '101';

----세션의 언어 변경 
ALTER SESSION SET
NLS_DATE_LANGUAGE = AMERICAN;

SELECT employee_id, TO_CHAR(hire_date, 'MM/YY') Month_Hired 
FROM employees;

--fm이 들어가면 앞의 공백을 지워줌 - 0을 지워줌 
SELECT last_name, 
    TO_CHAR(hire_date, 'fmDD Month YYYY') AS hiredate
 FROM employees;

SELECT last_name, 
        TO_CHAR(hire_date, 'fmDdspth "of" Month YYYY fmHH:MI:SS AM')
FROM employees;

--숫자에 to_char 함수 사용 
SELECT 
    TO_CHAR(salary, '$999,999.00') salary
FROM employees;

--문자를 숫자로 변환 -- 
SELECT TO_NUMBER ('$3,400', '$99,999')
FROM dual;

SELECT TO_DATE('2010년,02월','YYYY"년",MM"월"')
FROM dual;

SELECT last_name, hire_date
FROM employees
WHERE hire_date > TO_DATE('2005년 07월 01일 ', 'YYYY"년" MM"월" DD"일" ');


SELECT last_name, hire_date
FROM employees
WHERE hire_date > 
            TO_DATE ('05/07/01' ,  'YY-MM-DD');
            
SELECT last_name, salary, NVL (commission_pct, 0), (salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL
FROM employees;
--commision_pct 는 숫자형식이지만 '보너스없음'은 문자형식이라 실행에러 
SELECT last_name, salary, NVL (commission_pct, '보너스 없음')
FROM employees;
--에러 수정을 위해서는 아래처럼 문자 변환 해줘야함
 SELECT last_name, salary, NVL (TO_CHAR(commission_pct), '보너스 없음')
FROM employees;           

SELECT last_name, salary, commission_pct, 
            NVL2(commission_pct, 'SAL+COMM', 'SAL') income
FROM employees;
--first_name 과 last_name 의 길이가 같으면 null 출력. 같지않으면 first_name의 length 출력 
SELECT first_name, LENGTH(first_name) "expr1" , last_name, LENGTH(last_name) "expr2", NULLIF (LENGTH (first_name), LENGTH(last_name)) result
FROM employees;
--when / then 00이 when 00일 경우에 then 00 , 
SELECT last_name, job_id, salary,
        CASE job_id WHEN 'IT_PROG' THEN 1.10*salary
                            WHEN 'ST_CLERK' THEN 1.15*salary
                            WHEN 'SA_REP' THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;
--다른 방법
SELECT last_name, job_id, salary,
        CASE job_id WHEN job_id= 'IT_PROG'  THEN 1.10*salary
                            WHEN job_id='ST_CLERK' THEN 1.15*salary
                            WHEN job_id='SA_REP'      THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;

SELECT last_name, salary,
        CASE WHEN salary<5000 THEN 'Low'
                    WHEN salary<10000 THEN 'Medium'
                    WHEN salary<20000 THEN 'Good'
                    ELSE 'Excellent'
        END qualified_salary
FROM employees;

SELECT last_name, job_id, salary,
                DECODE(job_id, 'IT_PROG',    1.10*salary, 
                               'ST_CLERK',   1.15*salary,
                               'SA_REP',     1.20*salary, 
                                                  salary)
                REVISED_SALARY
FROM employees;

--연습문제 sql03_2.txt
--5)
SELECT  last_name,ROUND( MONTHS_BETWEEN (sysdate , hire_date)) AS MONTHS_WORKED
FROM employees;

--6) 
SELECT last_name, LPAD(salary, 15, '#') salary
FROM employees;

--7) 
SELECT last_name,ROUND( (sysdate- hire_date) /7) TENURE
FROM employees
WHERE department_id = 90;

--연습문제 sql04.txt 
--1)
SELECT  last_name ||' earns'||TO_CHAR(salary,'$999,999.00')||' but wants '|| TO_CHAR(3*salary,'$999,999.00')  AS "Dream Salaries."
FROM employees;

--2) 

SELECT * 
FROM employees;

ALTER SESSION SET
NLS_DATE_FORMAT = 'YYYY.MM.DD';
SELECT last_name, hire_date, TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월'),'YYYY.MM.DD DAY') AS REVIEW
FROM employees;


--3) 
SELECT last_name, hire_date, TO_CHAR(hire_date,'day') AS DAY
FROM employees
ORDER BY TO_CHAR(hire_date-1,'d');

--4) 
SELECT last_name, NVL2(TO_CHAR(commission_pct), TO_CHAR(commission_pct), 'No Commission') 
FROM employees;

--5)
SELECT last_name, job_id,
    DECODE(job_id, 'AD_PRES' ,'A',
                   'ST_MAN'  ,'B',
                   'IT_PROG' ,'C',
                   'SA_REP'  ,'D',
                   'ST_CLERK','E',
                              '0')
        AS "COMM"
FROM employees
ORDER BY COMM;


------그룹함수 
--AVG, MAX, MIN, SUM 
SELECT ROUND(AVG(salary)), MAX(salary), 
              MIN(salary), SUM(salary)
FROM employees
WHERE job_id LIKE '%REP%';

--날짜의 min max(null 제외)
SELECT MIN(hire_date), MAX(hire_date)
FROM employees;

--문자의 min max(null 제외)
SELECT MIN(last_name), MAX(last_name)
FROM employees;

--107개 출력 (*)총 갯수를 알려줌 
SELECT COUNT(*)
FROM employees;

--사원번호가 50인 직원들을 모두 몇명인지 알려줌 
SELECT COUNT(*)
FROM employees
WHERE department_id = 50;

--80번 부서 중에서 커미션 받는 직원은 몇명?
SELECT COUNT(commission_pct)
FROM employees
WHERE department_id = 80;

--distinct 소속된 부서의 갯수를 알려줌 / 
SELECT COUNT (DISTINCT department_id), 
              COUNT (department_id)
FROM employees;
--NULL 하나 포함됨 
SELECT DISTINCT department_id
FROM employees;
--앞에는 null값 포함 평균 / 뒤에는 null값 무시 커미션 받는 사람만 평균을 구한것. 
SELECT AVG(NVL(commission_pct, 0)), AVG(commission_pct)
FROM employees;

--GROUP BY 
SELECT department_id, ROUND(AVG(salary))
FROM employees
GROUP BY department_id;

SELECT  ROUND(AVG(salary))
FROM employees
GROUP BY department_id;


SELECT department_id, job_id, sum(salary),count(salary)
FROM employees
GROUP BY department_id, job_id
ORDER BY job_id;

SELECT department_id, job_id, sum(salary),count(salary)
FROM employees
WHERE department_id > 40
GROUP BY department_id, job_id
ORDER BY department_id;

--group함수를 조건으로 걸고 싶으면 having by 사용해야한다 
--having by 는 그룹함수와 함께 사용해야한다 
SELECT department_id, MAX(salary)
FROM employees
GROUP BY department_id 
HAVING MAX(salary) > 10000;

SELECT job_id, SUM(salary) PAYROLL
FROM employees
WHERE job_id NOT LIKE '%REP%'
GROUP BY job_id
HAVING SUM(salary) > 13000
ORDER BY SUM(salary);

--그룹함수는 두번까지만 중첩 가능.그룹함수 중첩할 경우 앞에 어떠한 일반컬럼도 올 수 없음 select절에 department_id 추가하면 오류남 
SELECT department_id, MAX(AVG(salary))
FROM employees
GROUP BY department_id;

------------ sql05.txt-------

--1) 1. 그룹 함수는 여러 행에 적용되어 그룹 당 하나의 결과를 출력한다.
true
--2) 2. 그룹 함수는 계산에 널을 포함한다.
false
--3) 3. WHERE 절은 그룹 계산에 행(row)을 포함시키기 전에 행을 제한한다.
true
--4) 모든 사원의 급여 최고액, 최저액, 총액 및 평균액을 표시하시오. 열 레이블을 각각 Maximum, Minimum, Sum 및 Average로 지정하고 결과를 정수로 반올림하도록 작성하시오.
SELECT MAX(salary) AS "Maximum", 
              MIN(salary) AS "Minimum", 
              SUM(salary) AS "Sum", 
              ROUND(AVG(salary)) AS "Salary" 
FROM employees;

--5)위의 질의를 수정하여 각 업무 유형(job_id)별로 급여 최고액, 최저액, 총액 및 평균액을 표시하시오. 
SELECT job_id, MAX(salary) AS "Maximum", 
                          MIN(salary) AS "Minimum", 
                          SUM(salary) AS "Sum", 
                          ROUND(AVG(salary)) AS "Salary" 
FROM employees
GROUP BY job_id;

--6)업무별 사원 수를 표시하는 질의를 작성하시오.
SELECT job_id,COUNT (employee_id)
FROM EMPLOYEES
GROUP BY job_id;

--7)관리자 수를 확인하시오. 열 레이블은 Number of Managers로 지정하시오. (힌트: MANAGER_ID 열을 사용)
SELECT COUNT(distinct manager_id) AS "Number of Managers"
FROM employees;

SELECT manager_id 
FROM employees;

--8)최고 급여와 최저 급여의 차액을 표시하는 질의를 작성하고 열 레이블을 DIFFERENCE로 지정하시오.
SELECT MAX(salary)-MIN(salary) AS DIFFERENCE 
FROM employees;

--9)관리자 번호 및 해당 관리자에 속한 사원의 최저 급여를 표시하시오. 관리자를 알 수 없는 사원 및 최저 급여가 6,000 미만인 그룹은 제외시키고 결과를 급여에 대한 내림차순으로 정렬하시오.
SELECT manager_id, MIN(salary)
FROM employees 
WHERE manager_id IS NOT NULL
GROUP BY manager_id 
HAVING MIN(salary) >= 6000
ORDER BY MIN(salary) DESC;

SELECT employee_id, last_name, department_id
FROM employees;

--department 27개 
SELECT count(*)
from departments;
--총 2889 출력됨 (107명*27개의 부서 = 2889)
--cartesian product - 오류 
SELECT last_name, department_name
FROM employees, departments;

----테이블 조인
-- 테이블 이름이 길때는 alias로 약자 만들어줌 
-- 조건: employees 테이블의 department_id 가 departments테이블의 department_id 와 같을 경우 
--106명 출력됨 (null 한명 제외)
SELECT e.employee_id, e.last_name, e.department_id, d.department_id,  d.location_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--접두어 넣지 않아도 출력은 됨.(대신 두가지 테이블 모두 비교하기 때문에 더 오랜시간 걸림) 하지만 중복되는 칼럼이라면 접두어 무조건 표시해야함  
SELECT employee_id, last_name, e.department_id, d.department_id,  location_id, department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

SELECT d.department_id, d.department_name, d.location_id, l.city
FROM departments d, locations l
WHERE d.location_id = l.location_id;

--추가 조건은 and로 가능 
SELECT d.department_id, d.department_name, d.location_id, l.city
FROM departments d, locations l
WHERE d.location_id = l.location_id
AND d.department_id IN (20,50);

SELECT *
FROM job_grades;

--비동등 조회 non equivalent
--BETWEEN AND 활용 
SELECT e.last_name, e.salary, j.grade_level
FROM employees e, job_grades j
WHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;

--outer join
--포함되지 않는 데이터도 같이 보고 싶을때 
--(+)를 붙여준 반대편의 정보를 보여줌( ex) e.departnent_id 에 지정이 되어있지 않은 부서들이 있을 수 있음. 그 값을 보여주기 위해 활용 
--(+)왼쪽에 있으면 right outer join, 오른쪽이면 left outer join %% 혼돈주의  
SELECT e.last_name, e.department_id, d.department_name 
FROM employees e, departments d
WHERE e.department_id(+) = d.department_id;

--아직 부서 배치가 되어있지 않은 직원이 출력됨 
SELECT e.last_name, e.department_id, d.department_name 
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);

--self join 
--같은 테이블을 서로 다른 테이블로 지정 후 비교하는 것 
SELECT worker.last_name || ' works for ' || manager.last_name
FROM employees worker, employees manager 
WHERE  worker.manager_id = manager.employee_id;

--cross join 안시 표준으로 작성 시 
SELECT last_name, department_name
FROM employees CROSS JOIN departments;

--natural join 
--두 테이블의 동일한 이름의 컬럼을 기준으로 조인 (location_id가 동일) 대신 데이터타입도 동일해야함 
SELECT department_id, department_name, location_id, city 
FROM departments NATURAL JOIN locations;

DESC departments;
DESC locations;

--using절= 같은 값을 가진 행을 선택해 지정해줌 
--칼럼이 같은 이름을 가지지만 데이터 타입이 다를때 / natural join 과 함께 쓸 수 없다. 
SELECT employee_id, last_name, location_id, department_id
FROM employees JOIN departments 
                                        USING (department_id);
                                        
--where절에는 alias 붙이면 안됨                                         
SELECT l.city, d.department_name
FROM locations l JOIN departments d
USING (location_id)
WHERE location_id = 1400;
--ansi 기준 join
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id
FROM employees e JOIN departments d
ON  (e.department_id = d.department_id);
--oracle 기준 join 
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--on절의 3way join 
--ansi 
SELECT employee_id, city, department_name
FROM employees e 
            JOIN departments d 
                    ON d.department_id = e.department_id
            JOIN locations l 
                    ON d.location_id = l.location_id;

--oracle 기준 join
SELECT employee_id, city, department_name
FROM employees e, departments d, locations l 
WHERE  d.department_id = e.department_id
AND d.location_id = l.location_id;

-ANSI 
SELECT e.last_name, e.department_id, d.department_name
FROM employees e FULL OUTER JOIN departments d
                    ON (e.department_id = d.department_id);

--ORACLE
                    SELECT e.last_name, e.department_id, d.department_name
FROM employees e , departments d
WHERE e.department_id(+) = d.department_id;

SELECT e.last_name, e.department_id, d.department_name
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
AND e.manager_id = 149;
--위아래 다 같은 결과 보여줌 
SELECT e.last_name, e.department_id, d.department_name
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
WHERE e.manager_id = 149;

-------------SQL06.TXT--------
--1)LOCATIONS 및 COUNTRIES 테이블을 사용하여 모든 부서의 주소를 생성하는 query를 작성하시오. 
--출력에 위치ID(location_id), 주소(street_address), 구/군(city), 시/도(state_province) 및 국가(country_name)를 표시하시오.
SELECT *
FROM locations;

SELECT *
FROM countries;


SELECT l.location_id, l.street_address, l.city, l.state_province, c.country_name 
FROM locations l , countries c
WHERE l.country_id = c.country_id;
--2)모든 사원의 이름, 소속 부서번호 및 부서 이름을 표시하는 query를 작성하시오.
SELECT *
FROM departments;
SELECT *
FROM employees;

SELECT e.last_name, d.department_id, d.department_name 
FROM departments d, employees e
WHERE d.department_id(+) = e.department_id;
--3)Toronto에 근무하는 사원에 대한 보고서를 필요로 합니다. toronto에서 근무하는 모든 사원의 이름, 직무, 부서번호 및 부서 이름을 표시하시오.
SELECT e.last_name, e.job_id, d.department_id, d.department_name
FROM departments d, employees e, locations l
WHERE l.location_id = d.location_id
AND d.department_id = e.department_id
AND LOWER(city) = 'toronto';
--4)사원의 이름 및 사원 번호를 해당 관리자의 이름 및 관리자 번호와 함께 표시하는 보고서를 작성하는데, 열 레이블을 각각 Employee, Emp#, Manager 및 Mgr#으로 지정하시오.
SELECT w.last_name AS "Employee", w.employee_id AS "Emp#", m.last_name AS "Manager", m.manager_id AS "Mgr#"
FROM employees w , employees m
WHERE  w.manager_id = m.manager_id;
--5)King과 같이 해당 관리자가 지정되지 않은 사원도 표시하도록 4번 문장을 수정합니다. 사원 번호순으로 결과를 정렬하시오. 
--(+) 위치한 곳에 null값을 추가해줘라--로 이해하면 됨 
SELECT w.last_name AS "Employee", w.employee_id AS "Emp#", m.last_name AS "Manager", m.manager_id AS "Mgr#"
FROM employees w , employees m
WHERE  w.manager_id = m.manager_id(+)
ORDER BY w.employee_id;
--6)직무 등급 및 급여에 대한 보고서를 필요로 합니다. 먼저 JOB_GRADES 테이블의 구조를 표시한 다음 모든 사원의 이름, 직무, 부서 이름, 급여 및 등급을 표시하는 query를 작성하시오.
--3절이 join 되면 최소 두개의 조건이 필요함 where, and fh 3가지 묶기 
SELECT e.last_name, e.job_id, d.department_name, e.salary, j.grade_level
FROM employees e, departments d, job_grades j
WHERE e.department_id = d.department_id 
AND e.salary BETWEEN j.lowest_sal AND j.highest_sal;

--------------서브쿼리----------
--쿼리 안 이너 쿼리.두개로 나누지 않고 안에 포함시킴 
--부서별로 최대 급여를 받는 사원의 이름과 급여 출력 
SELECT last_name, salary
FROM employees 
WHERE salary IN (SELECT MAX(salary)
                              FROM employees
                              GROUP BY department_id);
SELECT MAX(salary)
                              FROM employees
                              GROUP BY department_id;
                              
SELECT last_name, salary
FROM employees
WHERE salary > (SELECT salary 
                             FROM employees
                             WHERE last_name = 'Abel');
 --141사원과 같은 직군의 사번, 직원이름, job_id 출력                            
SELECT employee_id, last_name,job_id 
FROM employees
WHERE job_id > (SELECT job_id 
                             FROM employees
                             WHERE employee_id = 141);                             
--단 141번은 출려하지 마시오 
SELECT employee_id, last_name,job_id 
FROM employees
WHERE job_id > (SELECT job_id 
                             FROM employees
                             WHERE employee_id = 141)
AND employee_id != 141;

SELECT last_name, job_id, salary
FROM employees
WHERE job_id = (SELECT job_id
                             FROM employees
                             WHERE last_name = 'Taylor') --taylor 두명이라 에러남-single row 아님 / 이름 바꾸면 에러 안남 
AND salary > (SELECT salary
                             FROM employees
                             WHERE last_name = 'Taylor');

SELECT last_name, job_id, salary
FROM employees
WHERE salary = (SELECT MIN (salary)
                             FROM employees);

SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) > 
                                    (SELECT MIN(salary)
                                      FROM employees 
                                      WHERE department_id = 50);
 --가장 큰 값보다 적은 SALARY                                      
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ANY
                                    (SELECT salary 
                                    FROM employees
                                    WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';

--제일 작은 값보다 적은 값을 출력해줌 
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE salary < ALL
                                    (SELECT salary 
                                    FROM employees
                                    WHERE job_id = 'IT_PROG')
AND job_id <> 'IT_PROG';

--다중 열 서브쿼리 
--두개의 칼럼 비교 위해 where 사용 결합. 두가지 조건 다 만족해야 가능.묶어서 비교함 
--pairwise(15ro 출력됨) 쌍비교 . 주로 이걸로 사용해야함 
SELECT employee_id, manager_id, department_id
FROM empl_demo
WHERE (manager_id, department_id) IN 
                                                        (SELECT manager_id, department_id 
                                                        FROM empl_demo
                                                        WHERE first_name = 'John')
AND first_name != 'John';

--non-pairwise 비쌍비교 
--둘이 묶이지 않은 상태에서 비교하게 됨. 경우의 수가 늘어나 더 많은 내용이 출력됨 (20개)
SELECT employee_id, manager_id, department_id
FROM empl_demo
WHERE manager_id  IN 
                                 (SELECT manager_id
                                   FROM empl_demo
                                   WHERE first_name = 'John')
AND department_id IN 
                                  (SELECT department_id
                                   FROM empl_demo
                                   WHERE first_name = 'John')
AND first_name != 'John';
--데이터 삽입
INSERT INTO departments(department_id, department_name, manager_id, location_id)
VALUES (370, 'Public Relations',100,1700);
--모든 데이터를 다  추가하는거면 ( )안의 내용을 지워줘도 된다
INSERT INTO departments
VALUES (371, 'Public Relations',100,1700);

SELECT * 
FROM departments;

--특정 칼럼에만 데이터 입력 .입력하지 않은 칼럼에는 null삽입됨 (따로 null을 넣어줄수도 있음)
INSERT INTO departments(department_id, department_name)
VALUES (330, 'Purchasing');

INSERT INTO departments
VALUES (400, 'Finance', NULL, NULL);

SELECT * 
FROM departments;

INSERT INTO employees
VALUES (113, 'Louis', 'Popp', 'LPOPP','515.124.4567', SYSDATE, 'AC_ACCOUNT',6900,NULL,205,110);

SELECT *
FROM employees;

INSERT INTO employees
VALUES (114,'Den', 'Raphealy', 'DRAPHEAL', '515.127.4561', TO_DATE('FEB 3, 1999', 'MON DD, YYYY'), 'SA_REP', 11000,0.2,100,60);

--null값 대신 ''으로 써도 null로 들어감 
INSERT INTO departments
VALUES (100,'Finance','','');
-- & 사용해 입력할 값을 받을 수 있다. department_name은 문자형식이라 ' '안에 써줌 
--ex) department_id :40 , department_name: Human Resources , location_id:2500
INSERT INTO departments
                        (department_id, department_name,location_id)
VALUES (&department_id, '&department_name',&location);

SELECT * 
FROM departments;

SELECT *
FROM copy_emp;

INSERT INTO sales_reps
SELECT employee_id, last_name, salary,commission_pct
FROM employees
WHERE job_id LIKE '%REP%';

SELECT *
FROM sales_reps;

INSERT INTO copy_emp
SELECT *
FROM employees;
SELECT *
FROM copy_emp;
--오류 . ORA-01400: cannot insert NULL into ("HR"."DEPARTMENTS"."DEPARTMENT_ID") 
--department_id는 primary_key라 무조건 값이 들어가야함 
INSERT INTO departments(department_name)
VALUES ('Yedam');

--ORA-00001: unique constraint (HR.DEPT_ID_PK) violated
--department_id 는 유니크해야함. 이미 10번 부서가 있어서 에러 
INSERT INTO departments(department_id,department_name)
VALUES (10,'Yedam');

--에러 ORA-01400: cannot insert NULL into ("HR"."DEPARTMENTS"."DEPARTMENT_NAME")
INSERT INTO departments(department_id)
VALUES (130);
--오류ORA-02291: integrity constraint (HR.DEPT_MGR_FK) violated - parent key not found
--manager_id는 foreign key 100으로 변경해줘야 오류 없어짐  
INSERT INTO departments (department_id, department_name, manager_id)
VALUES(130,'YD',100);

UPDATE employees
SET department_id = 50
WHERE employee_id = 113;

SELECT * FROM employees;

--오류ORA-02291: integrity constraint (HR.EMP_DEPT_FK) violated - parent key not found
UPDATE employees
SET department_id = 51
WHERE employee_id = 113;
--where절 사용 안해서 모든 department_id 가 110으로 변경됨 
UPDATE copy_emp
SET department_id = 110;

SELECT *
FROM copy_emp;

UPDATE employees
SET job_id = 'IT_PROG', commission_pct = NULL
WHERE employee_id = 114;

SELECT * FROM employees;

ROLLBACK;
SELECT *
FROM COPY_EMP;

--삭제 
DELETE employees;

INSERT INTO copy_emp
SELECT *
FROM employees;

SELECT *
FROM copy_emp;

COMMIT;
--where절 없이 delete 하면 데이터가 다 삭제됨 
DELETE copy_emp;

ROLLBACK;

SELECT *
FROM copy_emp;

--finance 칼럼 지워주기 
DELETE FROM departments
WHERE department_name = 'Finance';

SELECT *
FROM departments;

DELETE FROM departments 
WHERE department_id IN (30,40);

SELECT *
FROM departments;

ROLLBACK;

SELECT *
FROM copy_emp;

DELETE copy_emp;

SELECT *
FROM copy_emp;

ROLLBACK;
--rollback 해도 돌아오지 않음.
TRUNCATE TABLE copy_emp;

SELECT *
FROM copy_emp;

ROLLBACK;

SELECT *
FROM copy_emp;
---------------------sql08.txt-------------------
--1)다음과 같이 실습에 사용할 MY_EMPLOYEE 테이블을 생성하시오.
CREATE TABLE my_employee
  (id         NUMBER(4) NOT NULL,
   last_name  VARCHAR2(25),
   first_name VARCHAR2(25),
   userid     VARCHAR2(8),
   salary     NUMBER(9,2));
   
   --2)MY_EMPLOYEE 테이블의 구조를 표시하여 열 이름을 식별하시오.
   DESC MY_EMPLOYEE;

   --3)다음 예제 데이터를 MY_EMPLOYEE 테이블에 추가하시오.
   ----이렇게 값을 입력받아서 추가할 수도 있음 
    INSERT INTO MY_EMPLOYEE
   VALUES (&id,'&last_name','&first_name','&userid',895);
   
   INSERT INTO MY_EMPLOYEE
   VALUES (1,'Patel','Ralph','Rpatel',895);
   
   INSERT INTO MY_EMPLOYEE
   VALUES  (2,'Dancs','Betty','Bdancs',860);
   
    INSERT INTO MY_EMPLOYEE
   VALUES (3,'Biri','Ben','Bbiri',1100);
   --4)테이블에 추가한 항목을 확인하시오.
   SELECT * 
   FROM MY_EMPLOYEE;
   --6)사원 3의 성을 Drexler로 변경하시오.
   UPDATE MY_EMPLOYEE
   SET last_name = 'Drexler'
   WHERE id = 3;
   
    SELECT * 
   FROM MY_EMPLOYEE;
   
   --7)급여가 900 미만인 모든 사원의 급여를 1000으로 변경하고 테이블의 변경 내용을 확인하시오.
   UPDATE MY_EMPLOYEE
   SET salary = 1000
   WHERE salary < 900;
   
   SELECT * 
   FROM MY_EMPLOYEE;
   --8)MY_EMPLOYEE 테이블에서 사원 3을 삭제하고 테이블의 변경 내용을 확인하시오.
   DELETE FROM MY_EMPLOYEE
   WHERE id = 3;
   
 SELECT * 
FROM MY_EMPLOYEE;
   --11)테이블의 내용을 모두 삭제하고 테이블 내용이 비어 있는지 확인하시오.
   
DELETE FROM MY_EMPLOYEE; --DML
TRUNCATE TABRE MY_EMPLOYEE; --DDL

SELECT * 
 FROM MY_EMPLOYEE;
 
 COMMIT;
 UPDATE employees
 SET salary = 99999
 WHERE employee_id = 176;
 
 SELECT * 
 FROM employees
 WHERE employee_id = 176;
 --이전 상태로 복구 
 ROLLBACK;
 
  SELECT * 
 FROM employees
 WHERE employee_id = 176;
 
 UPDATE employees
 SET salary = 99999
 WHERE employee_id = 176;
 
 COMMIT;
 
 SELECT * 
 FROM employees
 WHERE employee_id = 176;
 
 UPDATE employees
 SET salary = 99999
 WHERE employee_id = 176;
 
 TRUNCATE TABLE aa;
 --사용자가 소유한 테이블의 이름 출력
 SELECT table_name
 FROM user_tables;
 --사용자가 소유한 개별 객체 유형 출력
 SELECT DISTINCT object_type 
 FROM user_objects;
 --사용자가 소유한 테이블, 뷰, 동의어 및 시퀸스 출력 
 SELECT *
 FROM user_catalog;
 
 --table 생성 
 --hire_date의 default값을 sysdate로 넣었기 때문에 현재날짜로 출력
 CREATE TABLE hire_dates
                (id               NUMBER(8),
                hire_date DATE DEFAULT SYSDATE);

INSERT INTO hire_dates(id)
VALUES (35);

SELECT *
FROM hire_dates;

INSERT INTO hire_dates
VALUES (35,NULL);

SELECT *
FROM hire_dates;

CREATE TABLE dept
                    (deptno  NUMBER(2),
                     dname  VARCHAR2(14),
                     loc        VARCHAR2(13),
                     create_date DATE DEFAULT SYSDATE);
SELECT *
FROM dept;        

SELECT table_name
FROM user_tables;

--서브쿼리 사용 테이블 생성
--컬럼명을 따로 지정해주지 않으면 서브쿼리 
CREATE TABLE dept80
    AS
        SELECT  employee_id, last_name, salary*12 ANNSAL, hire_date
FROM employees
WHERE department_id = 80;

SELECT *
FROM dept80;        
--새로운 칼럼 추가됨 . 맨뒤에 추가됨 
--ADD 칼럼 추가 
ALTER TABLE dept80
ADD                (job_id VARCHAR2(9));

SELECT *
FROM dept80;       
--DEFAULT를 지정하면 항상 기본값을 넣어줌 
ALTER TABLE dept80
ADD                (hdate DATE DEFAULT SYSDATE);

SELECT *
FROM dept80; 

--MODIFY 
ALTER TABLE dept80
MODIFY         (last_name VARCHAR2(30));

ALTER TABLE dept80
MODIFY         (last_name VARCHAR2(10));
--들어있는 기본값보다 적게 줄이면 에러 
--ORA-01441: cannot decrease column length because some value is too big
ALTER TABLE dept80
MODIFY         (last_name VARCHAR2(5));

ALTER TABLE dept80
MODIFY  (job_id NUMBER (10));

SELECT *
FROM dept80; 
--데이터 type 오류
ALTER TABLE dept80
MODIFY  (last_name NUMBER (10));

--DROP:  칼럼 삭제 
--최소 한개의 칼럼은 남아있어야한다 
ALTER TABLE dept80 
DROP (job_id);

SELECT *
FROM dept80; 

--SET UNUSED
--숨김 기능- 블라인드 처리 - 이후 DROP하기 위해 사용. SET UNUSED 한 칼럼들은 복구안됨. 
ALTER TABLE dept80
SET UNUSED (last_name);
SELECT *
FROM dept80; 
--UNUSED 처리 한 칼럼들을 삭제해줌(주로 접속자가 많아서 비활성화시키기 어려울때 UNUSED활용 ->이후 삭제함 
ALTER TABLE dept80
DROP UNUSED COLUMNS;

SELECT *
FROM dept80; 

--TABLE삭제 
DROP TABLE dept80;
----휴지통 확인. 방금 삭제한 테이블 확인 가능 
SELECT*
FROM user_recyclebin;

--삭제한 테이블 복구 FLASHBACK
--ORACLE만 이 기능이 있음 
FLASHBACK TABLE dept80 TO BEFORE DROP;

SELECT *
FROM dept80; 

--영구삭제PURGE.휴지통 봐도 아무것도 없음 
--사용주의! 
DROP TABLE dept80 PURGE;

SELECT*
FROM user_recyclebin;

--RENAME
RENAME dept TO dept80;

--테이블 전체 삭제 
TRUNCATE TABLE dept80;
------------sql07.txt--------
--1)1. Zlotkey와 동일한 부서에 속한 모든 사원의 이름과 입사일을 표시하는 질의를 작성하시오. Zlotkey는 결과에서 제외하시오.
SELECT last_name, hire_date
FROM employees 
WHERE department_id IN (SELECT department_id 
                        FROM employees
                        WHERE LOWER(last_name)='zlotkey');
AND last_name != 'Zlotkey';

--2)급여가 평균 급여보다 많은 모든 사원의 사원 번호와 이름을 표시하는 질의를 작성하고 결과를 급여에 대해 오름차순으로 정렬하시오.
SELECT employee_id, last_name
FROM employees
WHERE salary > (SELECT AVG(salary)
                FROM employees)
ORDER BY salary;
--3)이름에 u가 포함된 사원과 같은 부서에서 일하는 모든 사원의 사원 번호와 이름을 표시하는 질의를 작성하고 질의를 실행하시오.
SELECT employee_id, last_name
FROM employees
WHERE department_id in(SELECT department_id
                        FROM employees
                        WHERE last_name LIKE '%u%');
--4)부서 위치 ID(location_id)가 1700인 모든 사원의 이름, 부서 번호 및 업무 ID를 표시하시오.
SELECT *
FROM employees;
--잘못된 풀이 
SELECT e.last_name, e.department_id, e.job_id
FROM employees e,locations l
WHERE l.location_id = (SELECT location_id
                     FROM locations
                     WHERE location_id = 1700);
--이게 정답 
SELECT last_name, department_id, job_id 
FROM   employees
WHERE  department_id IN (SELECT department_id 
                         FROM   departments
                         WHERE  location_id = 1700);

--5)King에게 보고하는(manager가 King) 모든 사원의 이름과 급여를 표시하시오.
SELECT *
FROM departments;

SELECT last_name, salary
FROM employees
WHERE manager_id = (SELECT employee_id
                    FROM employees
                    WHERE LOWER(last_name) ='king');
--6)Executive 부서의 모든 사원에 대한 부서 번호, 이름 및 업무 ID를 표시하시오.
SELECT e.department_id,e.last_name,e.job_id
FROM employees e,departments d
WHERE d.department_id = (SELECT department_id 
                       FROM departments
                       WHERE LOWER(department_name) ='executive');
--7)평균 급여보다 많은 급여를 받고 이름에 u가 포함된 사원과 같은 부서에서 근무하는 모든 사원의 사원 번호, 이름 및 급여를 표시하시오.
SELECT employee_id, last_name, salary
FROM employees 
WHERE salary >(SELECT AVG(salary)
                FROM employees)
AND last_name IN (SELECT last_name
                  FROM employees
                  WHERE LOWER(last_name) LIKE '%u%');
                  