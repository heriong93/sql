--정렬 시 기본default는 asc 오름차순
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date;

SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date DESC;

-- 칼럼의 이름 지정 후 이름으로 호출 
SELECT employee_id, last_name, salary*12 annsal 
FROM employees
ORDER BY annsal;

--칼럼의 순서번호로 호출
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY 3;

--부서는 오름차순으로 정렬 후, 그 안의 월급은 내림차순으로 정렬해줌
SELECT last_name, department_id, salary
FROM employees
ORDER BY department_id, salary DESC;

-- select에 hire_date가 없더라도 employee 테이블에 있기 때문에 정렬 가능
SELECT employee_id, salary 
FROM employees
ORDER BY hire_date;

-- &를 추가하면, employee_id 를 대체할 제목을 기재해 입력값을 받을 수 있다 //문자열은 ' '사이에 적어줘야함.
SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE employee_id = &employee_num;

--UNDEFINE 저장된 값을 지워줌
UNDEFINE &column_name;

-- 기재한 칼럼에 대한 값을 출력해줌 (employee_id, last_name, &column_name AKA입력값)
--WHERE 입력한 조건 입력
SELECT employee_id, last_name, job_id, &column_name
FROM employees
WHERE &condition
ORDER BY &order_column; 


--COLUMN_NAME 창이 뜨면 department_id 넣으면 SELECT에 포함됨. &&는 영구적인 값을 저장해줌 
SELECT employee_id, last_name, job_id, &&column_name
FROM employees
ORDER BY &column_name;


--영구 지정되어있어서 실행에러
SELECT employee_id, salary
FROM employees
ORDER BY &column_name;

--영구지정한 내용을 삭제하기 위해 UNDEFINE 사용
UNDEFINE &column_name;

SELECT *
FROM job_history;

--UNION은 중복된 값 제거해줌 employees 에 107개 job_history에 10개 . 중복값 2개 삭제된 값이 나옴 
SELECT employee_id
FROM employees
UNION
SELECT employee_id
FROM job_history;

--UNION ALL은 중복값이 제거안됨. 출력하면 총 107+10개 117개 다 나옴
SELECT employee_id
FROM employees
UNION ALL
SELECT employee_id
FROM job_history
ORDER BY employee_id;

--INTERSECT는 교차 된 값만 출력해줌. 즉 중복된 값만 나옴 
SELECT employee_id, job_id
FROM employees
INTERSECT
SELECT employee_id, job_id
FROM job_history;

--intersect의 순서가 바뀌어도 결과는 똑같이 나온다 
SELECT employee_id, job_id
FROM job_history
INTERSECT
SELECT employee_id, job_id
FROM employees;

--105개 출력 
SELECT employee_id, job_id
FROM employees
MINUS
SELECT employee_id, job_id
FROM job_history;

--8개 출력됨 . 
SELECT employee_id, job_id
FROM job_history
MINUS
SELECT employee_id, job_id
FROM employees;

DESC dual;

SELECT *
from dual;

SELECT sysdate
FROM dual;

--대소문자 구분 
SELECT 'The job id for ' || UPPER(last_name)|| ' is ' || LOWER(job_id) AS "EMPLOYEE DETAILS" 
FROM employees;

--이름을 찾을 때 칼럼의 모든 단어를 소문자로 묶어놓고 찾으면 실수없이 찾기 쉬워짐
SELECT employee_id, last_name, department_id
FROM employees
WHERE LOWER(last_name) = 'higgins';

-- substring 자리부터 잘라내겠다 
SELECT last_name, SUBSTR (last_name, 4)
FROM employees
WHERE department_id = 110;

--substring 2,2 두번째 자리에서 시작해서 두개만 잘라주기 
SELECT last_name, SUBSTR (last_name, 2,2)
FROM employees
WHERE department_id = 110;

--뒤에서부터 3번째 자리부터 2자리 
SELECT last_name, SUBSTR (last_name,-3,2)
FROM employees
WHERE department_id = 110;

SELECT employee_id, CONCAT(first_name, last_name) NAME,
job_id, LENGTH (last_name), INSTR (last_name, 'a') "Contains 'a'?"
FROM employees
WHERE SUBSTR (job_id, 4) = 'REP';

--LTRIM 왼쪽 문자 잘라내기 
SELECT LTRIM('yyedaymy', 'yea')
FROM dual;

--RTRIM 오른쪽 문자 잘라내기 
SELECT RTRIM('yyedaymy', 'yea')
FROM dual;
--ROUNDING반올림
SELECT 
        ROUND(345.678) AS round1,
        ROUND(345.678, 0) AS round2, 
        ROUND(345.678, 1) AS round3, 
        ROUND(345.678, -1)  AS round4
FROM dual;
--TRUNCATE 절삭 
SELECT 
        TRUNC(345.678) AS round1,
        TRUNC(345.678, 0) AS round2,
        TRUNC(345.678, 1) AS round3,
        TRUNC(345.678, -1)  AS round4
FROM dual;
--MOD: 월급을 5000으로 나눈 후 남은 값을 표출해줌 
SELECT last_name, salary, MOD(salary,5000)
FROM employees;

--1) 
SELECT sysdate AS "Date"
FROM dual;

--2) 
SELECT employee_id, last_name, salary, ROUND (salary *1.15) as "New Salary"
FROM employees;

--3) 
SELECT employee_id, last_name, salary, ROUND(salary*1.15) "New Salary", (salary*1.15) - salary "Increase"
FROM employees;

--4) 
SELECT UPPER(last_name) name, LENGTH(last_name) name_length 
FROM employees
WHERE UPPER (SUBSTR( last_name, 1,1)) IN ('J', 'A','M')
ORDER BY 1;

SELECT sysdate
FROM dual;

---------날짜함수-----
SELECT last_name, ROUND((SYSDATE- hire_date) /7) as weeks
FROM employees
WHERE department_id = 90;

SELECT employee_id, hire_date, MONTHS_BETWEEN (sysdate, hire_date) TENURE, 
ADD_MONTHS (hire_date, 6) REVIEW, 
NEXT_DAY (hire_date, '금'), LAST_DAY (hire_date)
FROM employees;

--오늘날짜 기준 year반올림(7월 기준 반올림) / month(15일 자정 중심으로 반올림)/ day (수요일 낮 12시 기준으로 반올림-그 다음주 혹은 전주로 반올림됨)/dd(하루의 가운데, 12시 기준)
SELECT 
    ROUND(SYSDATE, 'YEAR'), 
    ROUND(SYSDATE, 'MONTH'),
    ROUND(SYSDATE, 'DAY'),
    ROUND(SYSDATE, 'DD')
FROM dual;
--TRUNCATE YEAR(23년1월1일) MONTH(23년 12월 1일)
SELECT 
    TRUNC(SYSDATE, 'YEAR'), 
    TRUNC(SYSDATE, 'MONTH'),
    TRUNC(SYSDATE, 'DAY'),
    TRUNC(SYSDATE, 'DD')
FROM dual;

SELECT *
FROM employees
WHERE employee_id = '101';

----세션의 언어 변경 
ALTER SESSION SET
NLS_DATE_LANGUAGE = AMERICAN;

SELECT employee_id, TO_CHAR(hire_date, 'MM/YY') Month_Hired 
FROM employees;

--fm이 들어가면 앞의 공백을 지워줌 - 0을 지워줌 
SELECT last_name, 
    TO_CHAR(hire_date, 'fmDD Month YYYY') AS hiredate
 FROM employees;

SELECT last_name, 
        TO_CHAR(hire_date, 'fmDdspth "of" Month YYYY fmHH:MI:SS AM')
FROM employees;

--숫자에 to_char 함수 사용 
SELECT 
    TO_CHAR(salary, '$999,999.00') salary
FROM employees;

--문자를 숫자로 변환 -- 
SELECT TO_NUMBER ('$3,400', '$99,999')
FROM dual;

SELECT TO_DATE('2010년,02월','YYYY"년",MM"월"')
FROM dual;

SELECT last_name, hire_date
FROM employees
WHERE hire_date > TO_DATE('2005년 07월 01일 ', 'YYYY"년" MM"월" DD"일" ');


SELECT last_name, hire_date
FROM employees
WHERE hire_date > 
            TO_DATE ('05/07/01' ,  'YY-MM-DD');
            
SELECT last_name, salary, NVL (commission_pct, 0), (salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL
FROM employees;
--commision_pct 는 숫자형식이지만 '보너스없음'은 문자형식이라 실행에러 
SELECT last_name, salary, NVL (commission_pct, '보너스 없음')
FROM employees;
--에러 수정을 위해서는 아래처럼 문자 변환 해줘야함
 SELECT last_name, salary, NVL (TO_CHAR(commission_pct), '보너스 없음')
FROM employees;           

SELECT last_name, salary, commission_pct, 
            NVL2(commission_pct, 'SAL+COMM', 'SAL') income
FROM employees;
--first_name 과 last_name 의 길이가 같으면 null 출력. 같지않으면 first_name의 length 출력 
SELECT first_name, LENGTH(first_name) "expr1" , last_name, LENGTH(last_name) "expr2", NULLIF (LENGTH (first_name), LENGTH(last_name)) result
FROM employees;
--when / then 00이 when 00일 경우에 then 00 , 
SELECT last_name, job_id, salary,
        CASE job_id WHEN 'IT_PROG' THEN 1.10*salary
                            WHEN 'ST_CLERK' THEN 1.15*salary
                            WHEN 'SA_REP' THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;
--다른 방법
SELECT last_name, job_id, salary,
        CASE job_id WHEN job_id= 'IT_PROG'  THEN 1.10*salary
                            WHEN job_id='ST_CLERK' THEN 1.15*salary
                            WHEN job_id='SA_REP'      THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;

SELECT last_name, salary,
        CASE WHEN salary<5000 THEN 'Low'
                    WHEN salary<10000 THEN 'Medium'
                    WHEN salary<20000 THEN 'Good'
                    ELSE 'Excellent'
        END qualified_salary
FROM employees;

SELECT last_name, job_id, salary,
                DECODE(job_id, 'IT_PROG',    1.10*salary, 
                               'ST_CLERK',   1.15*salary,
                               'SA_REP',     1.20*salary, 
                                                  salary)
                REVISED_SALARY
FROM employees;

--연습문제 sql03_2.txt
--5)
SELECT  last_name,ROUND( MONTHS_BETWEEN (sysdate , hire_date)) AS MONTHS_WORKED
FROM employees;

--6) 
SELECT last_name, LPAD(salary, 15, '#') salary
FROM employees;

--7) 
SELECT last_name,ROUND( (sysdate- hire_date) /7) TENURE
FROM employees
WHERE department_id = 90;

--연습문제 sql04.txt 
--1)
SELECT  last_name ||' earns'||TO_CHAR(salary,'$999,999.00')||' but wants '|| TO_CHAR(3*salary,'$999,999.00')  AS "Dream Salaries."
FROM employees;

--2) 

SELECT * 
FROM employees;

ALTER SESSION SET
NLS_DATE_FORMAT = 'YYYY.MM.DD';
SELECT last_name, hire_date, TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월'),'YYYY.MM.DD DAY') AS REVIEW
FROM employees;


--3) 
SELECT last_name, hire_date, TO_CHAR(hire_date,'day') AS DAY
FROM employees
ORDER BY TO_CHAR(hire_date-1,'d');

--4) 
SELECT last_name, NVL2(TO_CHAR(commission_pct), TO_CHAR(commission_pct), 'No Commission') 
FROM employees;

--5)
SELECT last_name, job_id,
    DECODE(job_id, 'AD_PRES' ,'A',
                   'ST_MAN'  ,'B',
                   'IT_PROG' ,'C',
                   'SA_REP'  ,'D',
                   'ST_CLERK','E',
                              '0')
        AS "COMM"
FROM employees
ORDER BY COMM;


------그룹함수 
--AVG, MAX, MIN, SUM 
SELECT ROUND(AVG(salary)), MAX(salary), 
              MIN(salary), SUM(salary)
FROM employees
WHERE job_id LIKE '%REP%';

--날짜의 min max(null 제외)
SELECT MIN(hire_date), MAX(hire_date)
FROM employees;

--문자의 min max(null 제외)
SELECT MIN(last_name), MAX(last_name)
FROM employees;

--107개 출력 (*)총 갯수를 알려줌 
SELECT COUNT(*)
FROM employees;

--사원번호가 50인 직원들을 모두 몇명인지 알려줌 
SELECT COUNT(*)
FROM employees
WHERE department_id = 50;

--80번 부서 중에서 커미션 받는 직원은 몇명?
SELECT COUNT(commission_pct)
FROM employees
WHERE department_id = 80;

--distinct 소속된 부서의 갯수를 알려줌 / 
SELECT COUNT (DISTINCT department_id), 
              COUNT (department_id)
FROM employees;
--NULL 하나 포함됨 
SELECT DISTINCT department_id
FROM employees;
--앞에는 null값 포함 평균 / 뒤에는 null값 무시 커미션 받는 사람만 평균을 구한것. 
SELECT AVG(NVL(commission_pct, 0)), AVG(commission_pct)
FROM employees;

--GROUP BY 
SELECT department_id, ROUND(AVG(salary))
FROM employees
GROUP BY department_id;

SELECT  ROUND(AVG(salary))
FROM employees
GROUP BY department_id;


SELECT department_id, job_id, sum(salary),count(salary)
FROM employees
GROUP BY department_id, job_id
ORDER BY job_id;

SELECT department_id, job_id, sum(salary),count(salary)
FROM employees
WHERE department_id > 40
GROUP BY department_id, job_id
ORDER BY department_id;

--group함수를 조건으로 걸고 싶으면 having by 사용해야한다 
--having by 는 그룹함수와 함께 사용해야한다 
SELECT department_id, MAX(salary)
FROM employees
GROUP BY department_id 
HAVING MAX(salary) > 10000;

SELECT job_id, SUM(salary) PAYROLL
FROM employees
WHERE job_id NOT LIKE '%REP%'
GROUP BY job_id
HAVING SUM(salary) > 13000
ORDER BY SUM(salary);

--그룹함수는 두번까지만 중첩 가능.그룹함수 중첩할 경우 앞에 어떠한 일반컬럼도 올 수 없음 select절에 department_id 추가하면 오류남 
SELECT department_id, MAX(AVG(salary))
FROM employees
GROUP BY department_id;

------------ sql05.txt-------

--1) 1. 그룹 함수는 여러 행에 적용되어 그룹 당 하나의 결과를 출력한다.
true
--2) 2. 그룹 함수는 계산에 널을 포함한다.
false
--3) 3. WHERE 절은 그룹 계산에 행(row)을 포함시키기 전에 행을 제한한다.
true
--4) 모든 사원의 급여 최고액, 최저액, 총액 및 평균액을 표시하시오. 열 레이블을 각각 Maximum, Minimum, Sum 및 Average로 지정하고 결과를 정수로 반올림하도록 작성하시오.
SELECT MAX(salary) AS "Maximum", 
              MIN(salary) AS "Minimum", 
              SUM(salary) AS "Sum", 
              ROUND(AVG(salary)) AS "Salary" 
FROM employees;

--5)위의 질의를 수정하여 각 업무 유형(job_id)별로 급여 최고액, 최저액, 총액 및 평균액을 표시하시오. 
SELECT job_id, MAX(salary) AS "Maximum", 
                          MIN(salary) AS "Minimum", 
                          SUM(salary) AS "Sum", 
                          ROUND(AVG(salary)) AS "Salary" 
FROM employees
GROUP BY job_id;

--6)업무별 사원 수를 표시하는 질의를 작성하시오.
SELECT job_id,COUNT (employee_id)
FROM EMPLOYEES
GROUP BY job_id;

--7)관리자 수를 확인하시오. 열 레이블은 Number of Managers로 지정하시오. (힌트: MANAGER_ID 열을 사용)
SELECT COUNT(distinct manager_id) AS "Number of Managers"
FROM employees;

SELECT manager_id 
FROM employees;

--8)최고 급여와 최저 급여의 차액을 표시하는 질의를 작성하고 열 레이블을 DIFFERENCE로 지정하시오.
SELECT MAX(salary)-MIN(salary) AS DIFFERENCE 
FROM employees;

--9)관리자 번호 및 해당 관리자에 속한 사원의 최저 급여를 표시하시오. 관리자를 알 수 없는 사원 및 최저 급여가 6,000 미만인 그룹은 제외시키고 결과를 급여에 대한 내림차순으로 정렬하시오.
SELECT manager_id, MIN(salary)
FROM employees 
WHERE manager_id IS NOT NULL
GROUP BY manager_id 
HAVING MIN(salary) >= 6000
ORDER BY MIN(salary) DESC;

SELECT employee_id, last_name, department_id
FROM employees;

--department 27개 
SELECT count(*)
from departments;
--총 2889 출력됨 (107명*27개의 부서 = 2889)
--cartesian product - 오류 
SELECT last_name, department_name
FROM employees, departments;

----테이블 조인
-- 테이블 이름이 길때는 alias로 약자 만들어줌 
-- 조건: employees 테이블의 department_id 가 departments테이블의 department_id 와 같을 경우 
--106명 출력됨 (null 한명 제외)
SELECT e.employee_id, e.last_name, e.department_id, d.department_id,  d.location_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--접두어 넣지 않아도 출력은 됨.(대신 두가지 테이블 모두 비교하기 때문에 더 오랜시간 걸림) 하지만 중복되는 칼럼이라면 접두어 무조건 표시해야함  
SELECT employee_id, last_name, e.department_id, d.department_id,  location_id, department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

SELECT d.department_id, d.department_name, d.location_id, l.city
FROM departments d, locations l
WHERE d.location_id = l.location_id;

--추가 조건은 and로 가능 
SELECT d.department_id, d.department_name, d.location_id, l.city
FROM departments d, locations l
WHERE d.location_id = l.location_id
AND d.department_id IN (20,50);

SELECT *
FROM job_grades;

--비동등 조회 non equivalent
--BETWEEN AND 활용 
SELECT e.last_name, e.salary, j.grade_level
FROM employees e, job_grades j
WHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;

--outer join
--포함되지 않는 데이터도 같이 보고 싶을때 
--(+)를 붙여준 반대편의 정보를 보여줌( ex) e.departnent_id 에 지정이 되어있지 않은 부서들이 있을 수 있음. 그 값을 보여주기 위해 활용 
--(+)왼쪽에 있으면 right outer join, 오른쪽이면 left outer join %% 혼돈주의  
SELECT e.last_name, e.department_id, d.department_name 
FROM employees e, departments d
WHERE e.department_id(+) = d.department_id;

--아직 부서 배치가 되어있지 않은 직원이 출력됨 
SELECT e.last_name, e.department_id, d.department_name 
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);

--self join 
--같은 테이블을 서로 다른 테이블로 지정 후 비교하는 것 
SELECT worker.last_name || ' works for ' || manager.last_name
FROM employees worker, employees manager 
WHERE  worker.manager_id = manager.employee_id;

--cross join 안시 표준으로 작성 시 
SELECT last_name, department_name
FROM employees CROSS JOIN departments;

--natural join 
--두 테이블의 동일한 이름의 컬럼을 기준으로 조인 (location_id가 동일) 대신 데이터타입도 동일해야함 
SELECT department_id, department_name, location_id, city 
FROM departments NATURAL JOIN locations;

DESC departments;
DESC locations;

--using절= 같은 값을 가진 행을 선택해 지정해줌 
--칼럼이 같은 이름을 가지지만 데이터 타입이 다를때 / natural join 과 함께 쓸 수 없다. 
SELECT employee_id, last_name, location_id, department_id
FROM employees JOIN departments 
                                        USING (department_id);
                                        
--where절에는 alias 붙이면 안됨                                         
SELECT l.city, d.department_name
FROM locations l JOIN departments d
USING (location_id)
WHERE location_id = 1400;
--ansi 기준 join
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id
FROM employees e JOIN departments d
ON  (e.department_id = d.department_id);
--oracle 기준 join 
SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--on절의 3way join 
--ansi 
SELECT employee_id, city, department_name
FROM employees e 
            JOIN departments d 
                    ON d.department_id = e.department_id
            JOIN locations l 
                    ON d.location_id = l.location_id;

--oracle 기준 join
SELECT employee_id, city, department_name
FROM employees e, departments d, locations l 
WHERE  d.department_id = e.department_id
AND d.location_id = l.location_id;

-ANSI 
SELECT e.last_name, e.department_id, d.department_name
FROM employees e FULL OUTER JOIN departments d
                    ON (e.department_id = d.department_id);

--ORACLE
                    SELECT e.last_name, e.department_id, d.department_name
FROM employees e , departments d
WHERE e.department_id(+) = d.department_id;

SELECT e.last_name, e.department_id, d.department_name
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
AND e.manager_id = 149;
--위아래 다 같은 결과 보여줌 
SELECT e.last_name, e.department_id, d.department_name
FROM employees e JOIN departments d
ON (e.department_id = d.department_id)
WHERE e.manager_id = 149;

-------------SQL06.TXT--------
--1)LOCATIONS 및 COUNTRIES 테이블을 사용하여 모든 부서의 주소를 생성하는 query를 작성하시오. 
--출력에 위치ID(location_id), 주소(street_address), 구/군(city), 시/도(state_province) 및 국가(country_name)를 표시하시오.
SELECT *
FROM locations;

SELECT *
FROM countries;


SELECT l.location_id, l.street_address, l.city, l.state_province, c.country_name 
FROM locations l , countries c
WHERE l.country_id = c.country_id;
--2)모든 사원의 이름, 소속 부서번호 및 부서 이름을 표시하는 query를 작성하시오.
SELECT *
FROM departments;
SELECT *
FROM employees;

SELECT e.last_name, d.department_id, d.department_name 
FROM departments d, employees e
WHERE d.department_id(+) = e.department_id;
--3)Toronto에 근무하는 사원에 대한 보고서를 필요로 합니다. toronto에서 근무하는 모든 사원의 이름, 직무, 부서번호 및 부서 이름을 표시하시오.
SELECT e.last_name, e.job_id, d.department_id, d.department_name
FROM departments d, employees e, locations l
WHERE l.location_id = d.location_id
AND d.department_id = e.department_id
AND LOWER(city) = 'toronto';
--4)사원의 이름 및 사원 번호를 해당 관리자의 이름 및 관리자 번호와 함께 표시하는 보고서를 작성하는데, 열 레이블을 각각 Employee, Emp#, Manager 및 Mgr#으로 지정하시오.
SELECT w.last_name AS "Employee", w.employee_id AS "Emp#", m.last_name AS "Manager", m.manager_id AS "Mgr#"
FROM employees w , employees m
WHERE  w.manager_id = m.manager_id;
--5)King과 같이 해당 관리자가 지정되지 않은 사원도 표시하도록 4번 문장을 수정합니다. 사원 번호순으로 결과를 정렬하시오. 
--(+) 위치한 곳에 null값을 추가해줘라--로 이해하면 됨 
SELECT w.last_name AS "Employee", w.employee_id AS "Emp#", m.last_name AS "Manager", m.manager_id AS "Mgr#"
FROM employees w , employees m
WHERE  w.manager_id = m.manager_id(+)
ORDER BY w.employee_id;
--6)직무 등급 및 급여에 대한 보고서를 필요로 합니다. 먼저 JOB_GRADES 테이블의 구조를 표시한 다음 모든 사원의 이름, 직무, 부서 이름, 급여 및 등급을 표시하는 query를 작성하시오.
--3절이 join 되면 최소 두개의 조건이 필요함 where, and fh 3가지 묶기 
SELECT e.last_name, e.job_id, d.department_name, e.salary, j.grade_level
FROM employees e, departments d, job_grades j
WHERE e.department_id = d.department_id 
AND e.salary BETWEEN j.lowest_sal AND j.highest_sal;

--------------서브쿼리----------
--쿼리 안 이너 쿼리.두개로 나누지 않고 안에 포함시킴 
--부서별로 최대 급여를 받는 사원의 이름과 급여 출력 
SELECT last_name, salary
FROM employees 
WHERE salary IN (SELECT MAX(salary)
                              FROM employees
                              GROUP BY department_id);
SELECT MAX(salary)
                              FROM employees
                              GROUP BY department_id;
                              
SELECT last_name, salary
FROM employees
WHERE salary > (SELECT salary 
                             FROM employees
                             WHERE last_name = 'Abel');
 --141사원과 같은 직군의 사번, 직원이름, job_id 출력                            
SELECT employee_id, last_name,job_id 
FROM employees
WHERE job_id > (SELECT job_id 
                             FROM employees
                             WHERE employee_id = 141);                             
--단 141번은 출려하지 마시오 
SELECT employee_id, last_name,job_id 
FROM employees
WHERE job_id > (SELECT job_id 
                             FROM employees
                             WHERE employee_id = 141)
AND employee_id != 141;

SELECT last_name, job_id, salary
FROM employees
WHERE job_id = (SELECT job_id
                             FROM employees
                             WHERE last_name = 'Taylor') --taylor 두명이라 에러남-single row 아님 / 이름 바꾸면 에러 안남 
AND salary > (SELECT salary
                             FROM employees
                             WHERE last_name = 'Taylor');
