--정렬 시 기본default는 asc 오름차순
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date;

SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY hire_date DESC;

-- 칼럼의 이름 지정 후 이름으로 호출 
SELECT employee_id, last_name, salary*12 annsal 
FROM employees
ORDER BY annsal;

--칼럼의 순서번호로 호출
SELECT last_name, job_id, department_id, hire_date
FROM employees
ORDER BY 3;

--부서는 오름차순으로 정렬 후, 그 안의 월급은 내림차순으로 정렬해줌
SELECT last_name, department_id, salary
FROM employees
ORDER BY department_id, salary DESC;

-- select에 hire_date가 없더라도 employee 테이블에 있기 때문에 정렬 가능
SELECT employee_id, salary 
FROM employees
ORDER BY hire_date;

-- &를 추가하면, employee_id 를 대체할 제목을 기재해 입력값을 받을 수 있다 //문자열은 ' '사이에 적어줘야함.
SELECT employee_id, last_name, salary, department_id
FROM employees
WHERE employee_id = &employee_num;

--UNDEFINE 저장된 값을 지워줌
UNDEFINE &column_name;

-- 기재한 칼럼에 대한 값을 출력해줌 (employee_id, last_name, &column_name AKA입력값)
--WHERE 입력한 조건 입력
SELECT employee_id, last_name, job_id, &column_name
FROM employees
WHERE &condition
ORDER BY &order_column; 


--COLUMN_NAME 창이 뜨면 department_id 넣으면 SELECT에 포함됨. &&는 영구적인 값을 저장해줌 
SELECT employee_id, last_name, job_id, &&column_name
FROM employees
ORDER BY &column_name;


--영구 지정되어있어서 실행에러
SELECT employee_id, salary
FROM employees
ORDER BY &column_name;

--영구지정한 내용을 삭제하기 위해 UNDEFINE 사용
UNDEFINE &column_name;

SELECT *
FROM job_history;

--UNION은 중복된 값 제거해줌 employees 에 107개 job_history에 10개 . 중복값 2개 삭제된 값이 나옴 
SELECT employee_id
FROM employees
UNION
SELECT employee_id
FROM job_history;

--UNION ALL은 중복값이 제거안됨. 출력하면 총 107+10개 117개 다 나옴
SELECT employee_id
FROM employees
UNION ALL
SELECT employee_id
FROM job_history
ORDER BY employee_id;

--INTERSECT는 교차 된 값만 출력해줌. 즉 중복된 값만 나옴 
SELECT employee_id, job_id
FROM employees
INTERSECT
SELECT employee_id, job_id
FROM job_history;

--intersect의 순서가 바뀌어도 결과는 똑같이 나온다 
SELECT employee_id, job_id
FROM job_history
INTERSECT
SELECT employee_id, job_id
FROM employees;

--105개 출력 
SELECT employee_id, job_id
FROM employees
MINUS
SELECT employee_id, job_id
FROM job_history;

--8개 출력됨 . 
SELECT employee_id, job_id
FROM job_history
MINUS
SELECT employee_id, job_id
FROM employees;

DESC dual;

SELECT *
from dual;

SELECT sysdate
FROM dual;

--대소문자 구분 
SELECT 'The job id for ' || UPPER(last_name)|| ' is ' || LOWER(job_id) AS "EMPLOYEE DETAILS" 
FROM employees;

--이름을 찾을 때 칼럼의 모든 단어를 소문자로 묶어놓고 찾으면 실수없이 찾기 쉬워짐
SELECT employee_id, last_name, department_id
FROM employees
WHERE LOWER(last_name) = 'higgins';

-- substring 자리부터 잘라내겠다 
SELECT last_name, SUBSTR (last_name, 4)
FROM employees
WHERE department_id = 110;

--substring 2,2 두번째 자리에서 시작해서 두개만 잘라주기 
SELECT last_name, SUBSTR (last_name, 2,2)
FROM employees
WHERE department_id = 110;

--뒤에서부터 3번째 자리부터 2자리 
SELECT last_name, SUBSTR (last_name,-3,2)
FROM employees
WHERE department_id = 110;

SELECT employee_id, CONCAT(first_name, last_name) NAME,
job_id, LENGTH (last_name), INSTR (last_name, 'a') "Contains 'a'?"
FROM employees
WHERE SUBSTR (job_id, 4) = 'REP';

--LTRIM 왼쪽 문자 잘라내기 
SELECT LTRIM('yyedaymy', 'yea')
FROM dual;

--RTRIM 오른쪽 문자 잘라내기 
SELECT RTRIM('yyedaymy', 'yea')
FROM dual;
--ROUNDING반올림
SELECT 
        ROUND(345.678) AS round1,
        ROUND(345.678, 0) AS round2, 
        ROUND(345.678, 1) AS round3, 
        ROUND(345.678, -1)  AS round4
FROM dual;
--TRUNCATE 절삭 
SELECT 
        TRUNC(345.678) AS round1,
        TRUNC(345.678, 0) AS round2,
        TRUNC(345.678, 1) AS round3,
        TRUNC(345.678, -1)  AS round4
FROM dual;
--MOD: 월급을 5000으로 나눈 후 남은 값을 표출해줌 
SELECT last_name, salary, MOD(salary,5000)
FROM employees;

--1) 
SELECT sysdate AS "Date"
FROM dual;

--2) 
SELECT employee_id, last_name, salary, ROUND (salary *1.15) as "New Salary"
FROM employees;

--3) 
SELECT employee_id, last_name, salary, ROUND(salary*1.15) "New Salary", (salary*1.15) - salary "Increase"
FROM employees;

--4) 
SELECT UPPER(last_name) name, LENGTH(last_name) name_length 
FROM employees
WHERE UPPER (SUBSTR( last_name, 1,1)) IN ('J', 'A','M')
ORDER BY 1;

SELECT sysdate
FROM dual;

---------날짜함수-----
SELECT last_name, ROUND((SYSDATE- hire_date) /7) as weeks
FROM employees
WHERE department_id = 90;

SELECT employee_id, hire_date, MONTHS_BETWEEN (sysdate, hire_date) TENURE, 
ADD_MONTHS (hire_date, 6) REVIEW, 
NEXT_DAY (hire_date, '금'), LAST_DAY (hire_date)
FROM employees;

--오늘날짜 기준 year반올림(7월 기준 반올림) / month(15일 자정 중심으로 반올림)/ day (수요일 낮 12시 기준으로 반올림-그 다음주 혹은 전주로 반올림됨)/dd(하루의 가운데, 12시 기준)
SELECT 
    ROUND(SYSDATE, 'YEAR'), 
    ROUND(SYSDATE, 'MONTH'),
    ROUND(SYSDATE, 'DAY'),
    ROUND(SYSDATE, 'DD')
FROM dual;
--TRUNCATE YEAR(23년1월1일) MONTH(23년 12월 1일)
SELECT 
    TRUNC(SYSDATE, 'YEAR'), 
    TRUNC(SYSDATE, 'MONTH'),
    TRUNC(SYSDATE, 'DAY'),
    TRUNC(SYSDATE, 'DD')
FROM dual;

SELECT *
FROM employees
WHERE employee_id = '101';

----세션의 언어 변경 
ALTER SESSION SET
NLS_DATE_LANGUAGE = AMERICAN;

SELECT employee_id, TO_CHAR(hire_date, 'MM/YY') Month_Hired 
FROM employees;

--fm이 들어가면 앞의 공백을 지워줌 - 0을 지워줌 
SELECT last_name, 
    TO_CHAR(hire_date, 'fmDD Month YYYY') AS hiredate
 FROM employees;

SELECT last_name, 
        TO_CHAR(hire_date, 'fmDdspth "of" Month YYYY fmHH:MI:SS AM')
FROM employees;

--숫자에 to_char 함수 사용 
SELECT 
    TO_CHAR(salary, '$999,999.00') salary
FROM employees;

--문자를 숫자로 변환 -- 
SELECT TO_NUMBER ('$3,400', '$99,999')
FROM dual;

SELECT TO_DATE('2010년,02월','YYYY"년",MM"월"')
FROM dual;

SELECT last_name, hire_date
FROM employees
WHERE hire_date > TO_DATE('2005년 07월 01일 ', 'YYYY"년" MM"월" DD"일" ');


SELECT last_name, hire_date
FROM employees
WHERE hire_date > 
            TO_DATE ('05/07/01' ,  'YY-MM-DD');
            
SELECT last_name, salary, NVL (commission_pct, 0), (salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL
FROM employees;
--commision_pct 는 숫자형식이지만 '보너스없음'은 문자형식이라 실행에러 
SELECT last_name, salary, NVL (commission_pct, '보너스 없음')
FROM employees;
--에러 수정을 위해서는 아래처럼 문자 변환 해줘야함
 SELECT last_name, salary, NVL (TO_CHAR(commission_pct), '보너스 없음')
FROM employees;           

SELECT last_name, salary, commission_pct, 
            NVL2(commission_pct, 'SAL+COMM', 'SAL') income
FROM employees;
--first_name 과 last_name 의 길이가 같으면 null 출력. 같지않으면 first_name의 length 출력 
SELECT first_name, LENGTH(first_name) "expr1" , last_name, LENGTH(last_name) "expr2", NULLIF (LENGTH (first_name), LENGTH(last_name)) result
FROM employees;
--when / then 00이 when 00일 경우에 then 00 , 
SELECT last_name, job_id, salary,
        CASE job_id WHEN 'IT_PROG' THEN 1.10*salary
                            WHEN 'ST_CLERK' THEN 1.15*salary
                            WHEN 'SA_REP' THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;
--다른 방법
SELECT last_name, job_id, salary,
        CASE job_id WHEN job_id= 'IT_PROG'  THEN 1.10*salary
                            WHEN job_id='ST_CLERK' THEN 1.15*salary
                            WHEN job_id='SA_REP'      THEN 1.20*salary
                            ELSE salary 
        END "REVISED_SALARY"
FROM employees;

SELECT last_name, salary,
        CASE WHEN salary<5000 THEN 'Low'
                    WHEN salary<10000 THEN 'Medium'
                    WHEN salary<20000 THEN 'Good'
                    ELSE 'Excellent'
        END qualified_salary
FROM employees;

SELECT last_name, job_id, salary,
                DECODE(job_id, 'IT_PROG',    1.10*salary, 
                               'ST_CLERK',   1.15*salary,
                               'SA_REP',     1.20*salary, 
                                                  salary)
                REVISED_SALARY
FROM employees;

--연습문제 sql03_2.txt
--5)
SELECT  last_name,ROUND( MONTHS_BETWEEN (sysdate , hire_date)) AS MONTHS_WORKED
FROM employees;

--6) 
SELECT last_name, LPAD(salary, 15, '#') salary
FROM employees;

--7) 
SELECT last_name,ROUND( (sysdate- hire_date) /7) TENURE
FROM employees
WHERE department_id = 90;

--연습문제 sql04.txt 
--1)
SELECT  last_name ||' earns'||TO_CHAR(salary,'$999,999.00')||' but wants '|| TO_CHAR(3*salary,'$999,999.00')  AS "Dream Salaries."
FROM employees;

--2) 

SELECT * 
FROM employees;

ALTER SESSION SET
NLS_DATE_FORMAT = 'YYYY.MM.DD';
SELECT last_name, hire_date, TO_CHAR(NEXT_DAY(ADD_MONTHS(hire_date,6),'월'),'YYYY.MM.DD DAY') AS REVIEW
FROM employees;


--3) 
SELECT last_name, hire_date, TO_CHAR(hire_date,'day') AS DAY
FROM employees
ORDER BY TO_CHAR(hire_date-1,'d');

--4) 
SELECT last_name, NVL2(TO_CHAR(commission_pct), TO_CHAR(commission_pct), 'No Commission') 
FROM employees;

--5)
SELECT last_name, job_id,
    DECODE(job_id, 'AD_PRES' ,'A',
                   'ST_MAN'  ,'B',
                   'IT_PROG' ,'C',
                   'SA_REP'  ,'D',
                   'ST_CLERK','E',
                              '0')
        AS "COMM"
FROM employees
ORDER BY COMM;



